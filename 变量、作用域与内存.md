JavaScript 变量是
松散类型的，而且变量不过就是特定时间点一个特定值的名称而已。由于没有规则定义变量必须包含什
么数据类型，变量的值和数据类型在脚本生命期内可以改变
#### 原始值与引用值
ECMAScript 变量可以包含两种不同类型的数据：原始值和引用值。原始值（primitive value）就是
最简单的数据，引用值（reference value）则是由多个值构成的对象。
在把一个值赋给变量时，JavaScript 引擎必须确定这个值是原始值还是引用值。上一章讨论了 6 种
原始值：Undefined、Null、Boolean、Number、String 和 Symbol。保存原始值的变量是按值（by
value）访问的，因为我们操作的就是存储在变量中的实际值。
引用值是保存在内存中的对象。与其他语言不同，JavaScript 不允许直接访问内存位置，因此也就
不能直接操作对象所在的内存空间。在操作对象时，实际上操作的是对该对象的引用（reference）而非
实际的对象本身。为此，保存引用值的变量是按引用（by reference）访问的。
##### 动态属性
原始值和引用值的定义方式很类似，都是创建一个变量，然后给它赋一个值。不过，在变量保存了
这个值之后，可以对这个值做什么，则大有不同。对于引用值而言，可以随时添加、修改和删除其属性
和方法。
原始值不能有属性，尽管尝试给原始值添加属性不会报错。比如：
let name = "Nicholas";
name.age = 27;
console.log(name.age); // undefined 
#####  复制值
和Java一样
##### 确定类型
前一章提到的 typeof 操作符最适合用来判断一个变量是否为原始类型。更确切地说，它是判断一
个变量是否为字符串、数值、布尔值或 undefined 的最好方式，typeof 虽然对原始值很有用，但它对引用值的用处不大
result = variable instanceof constructor
如果变量是给定引用类型的实例，则 instanceof 操作
符返回 true
##### 执行上下文与作用域
执行上下文（以下简称“上下文”）的概念在 JavaScript 中是颇为重要的。变量或函数的上下文决定
了它们可以访问哪些数据，以及它们的行为。每个上下文都有一个关联的变量对象（variable object），
而这个上下文中定义的所有变量和函数都存在于这个对象上。虽然无法通过代码访问变量对象，但后台
处理数据会用到它。其实和Java的一样，就是全局，成员的意思。
##### 变量声明
1. 使用 var 的函数作用域声明
在使用 var 声明变量时，变量会被自动添加到最接近的上下文
2. 使用 let 的块级作用域声明
ES6 新增的 let 关键字跟 var 很相似，但它的作用域是块级的
使用 const 的常量声明
除了 let，ES6 同时还增加了 const 关键字。使用 const 声明的变量必须同时初始化为某个值。
一经声明，在其生命周期的任何时候都不能再重新赋予新值。和final类似

#### 垃圾回收
过两种主要的标记策略：标记清理和引用计数。Java一般有以下几种（引用计数，复制，标记清理，标记整理）

##### 标记清理
当变量进入上下文，比如在函数
内部声明一个变量时，这个变量会被加上存在于上下文中的标记。而在上下文中的变量，逻辑上讲，永
远不应该释放它们的内存，因为只要上下文中的代码在运行，就有可能用到它们。当变量离开上下文时，
也会被加上离开上下文的标记。
##### 引用计数
。其思路是对每个值都记录它被
引用的次数。声明变量并给它赋一个引用值时，这个值的引用数为 1。如果同一个值又被赋给另一个变
量，那么引用数加 1。类似地，如果保存对该值引用的变量被其他值给覆盖了，那么引用数减 1。当一
个值的引用数为 0 时，就说明没办法再访问到这个值了，因此可以安全地收回其内存了。
##### 内存管理
1. 通过 const 和 let 声明提升性能
2. 隐藏类和删除操作
    比如下面的代码：
function Article() {
 this.title = 'Inauguration Ceremony Features Kazoo Band';
}
let a1 = new Article();
let a2 = new Article();
V8 会在后台配置，让这两个类实例共享相同的隐藏类，因为这两个实例共享同一个构造函数和原
型。假设之后又添加了下面这行代码：
a2.author = 'Jake';
此时两个 Article 实例就会对应两个不同的隐藏类。根据这种操作的频率和隐藏类的大小，这有
可能对性能产生明显影响。
当然，解决方案就是避免 JavaScript 的“先创建再补充”（ready-fire-aim）式的动态属性赋值，并在
构造函数中一次性声明所有属性，如下所示：
function Article(opt_author) {
 this.title = 'Inauguration Ceremony Features Kazoo Band';
 this.author = opt_author;
}
let a1 = new Article();
let a2 = new Article('Jake');
这样，两个实例基本上就一样了
3. 内存泄漏
使用 JavaScript 闭包很容易在不知不觉间造成内存泄漏
4.  静态分配与对象池
由于 JavaScript 数组的大小是动态可变的，引擎会删除大小为 100 的数组，再创建一个新的大小为
200 的数组。垃圾回收程序会看到这个删除操作，说不定因此很快就会跑来收一次垃圾。要避免这种动
态分配操作，可以在初始化时就创建一个大小够用的数组，从而避免上述先删除再创建的操作。不过，
必须事先想好这个数组有多大。
