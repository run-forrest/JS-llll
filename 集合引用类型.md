### Object
显式地创建 Object 的实例有两种方式。第一种是使用 new 操作符和 Object 构造函数，如下所示：
let person = new Object();
person.name = "Nicholas";
person.age = 29;
另一种方式是使用对象字面量（object literal）表示法。对象字面量是对象定义的简写形式，目的是
为了简化包含大量属性的对象的创建。比如，下面的代码定义了与前面示例相同的 person 对象，但使
用的是对象字面量表示法：
let person = {
 name: "Nicholas",
 age: 29
}; 

### Array
ECMAScript 数组也是一组有序的数据，但跟其他语言
不同的是，数组中每个槽位可以存储任意类型的数据。这意味着可以创建一个数组，它的第一个元素
是字符串，第二个元素是数值，第三个是对象。ECMAScript 数组也是动态大小的，会随着数据添加而
自动增长。和ArrayList一样。
有几种基本的方式可以创建数组。一种是使用 Array 构造函数，比如：
let colors = new Array();
如果知道数组中元素的数量，那么可以给构造函数传入一个数值，然后 length 属性就会被自动创
建并设置为这个值。比如，下面的代码会创建一个初始 length 为 20 的数组：
let colors = new Array(20);
也可以给 Array 构造函数传入要保存的元素。比如，下面的代码会创建一个包含 3 个字符串值的
数组：
let colors = new Array("red", "blue", "green"); 
Array.from()的第一个参数是一个类数组对象，即任何可迭代的结构，或者有一个 length 属性
和可索引元素的结构。
Array.of()可以把一组参数转换为数组。这个方法用于替代在 ES6之前常用的 Array.prototype.
slice.call(arguments)，一种异常笨拙的将 arguments 对象转换为数组的写法：
console.log(Array.of(1, 2, 3, 4)); // [1, 2, 3, 4]
console.log(Array.of(undefined)); // [undefined]
### 数组空位
使用数组字面量初始化数组时，可以使用一串逗号来创建空位（hole）。ECMAScript 会将逗号之间
相应索引位置的值当成空位，ES6 规范重新定义了该如何处理这些空位。
### 数组索引
### 定型数组
定型数组（typed array）是 ECMAScript 新增的结构，目的是提升向原生库传输数据的效率。实际上，
JavaScript 并没有“TypedArray”类型，它所指的其实是一种特殊的包含数值类型的数组。
#### ArrayBuffer
Float32Array 实际上是一种“视图”，可以允许 JavaScript 运行时访问一块名为 ArrayBuffer 的
预分配内存。ArrayBuffer 是所有定型数组及视图引用的基本单位
ArrayBuffer()是一个普通的 JavaScript 构造函数，可用于在内存中分配特定数量的字节空间。
const buf = new ArrayBuffer(16); // 在内存中分配 16 字节
alert(buf.byteLength); // 16
ArrayBuffer 一经创建就不能再调整大小。不过，可以使用 slice()复制其全部或部分到一个新
实例中：
const buf1 = new ArrayBuffer(16);
const buf2 = buf1.slice(4, 12);
alert(buf2.byteLength); // 8 
ArrayBuffer 某种程度上类似于 C++的 malloc()，但也有几个明显的区别。
malloc()在分配失败时会返回一个 null 指针。ArrayBuffer 在分配失败时会抛出错误。
malloc()可以利用虚拟内存，因此最大可分配尺寸只受可寻址系统内存限制。ArrayBuffer
分配的内存不能超过 Number.MAX_SAFE_INTEGER（253  1）字节。
malloc()调用成功不会初始化实际的地址。声明 ArrayBuffer 则会将所有二进制位初始化
为 0。
通过 malloc()分配的堆内存除非调用 free()或程序退出，否则系统不能再使用。而通过声明
ArrayBuffer 分配的堆内存可以被当成垃圾回收，不用手动释放。
不能仅通过对 ArrayBuffer 的引用就读取或写入其内容。要读取或写入 ArrayBuffer，就必须
通过视图。视图有不同的类型，但引用的都是 ArrayBuffer 中存储的二进制数据。
#### DataView
第一种允许你读写 ArrayBuffer 的视图是 DataView。这个视图专为文件 I/O 和网络 I/O 设计，其
API 支持对缓冲数据的高度控制，但相比于其他类型的视图性能也差一些。DataView 对缓冲内容没有
任何预设，也不能迭代。
必须在对已有的 ArrayBuffer 读取或写入时才能创建 DataView 实例。这个实例可以使用全部或
部分 ArrayBuffer，且维护着对该缓冲实例的引用，以及视图在缓冲中开始的位置。
